package actually.portals.ActuallySize.world.grid.construction.cube;

import actually.portals.ActuallySize.world.grid.construction.rect.ASIGRSingle;
import actually.portals.ActuallySize.world.grid.construction.rect.ASIGRectConstructor;
import gunging.ootilities.GungingOotilitiesMod.ootilityception.OotilityNumbers;
import net.minecraft.world.phys.Vec2;
import net.minecraft.world.phys.Vec3;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;

/**
 * A cube constructor that makes a cube by
 * filling in layer by layers of rect
 *
 * @since 1.0.0
 * @author Actually Portals
 */
public class ASIGCLayered extends ASIGCubeConstructor {

    /**
     * @param s      The scale of the grid, presumably the ceil of the
     *               player's scale who is building this so that it
     *               is a non-zero natural number.
     * @param origin A shift to the points generated by this rect
     * @author Actually Portals
     * @since 1.0.0
     */
    public ASIGCLayered(int s, @NotNull Vec3 origin) { super(s, origin); }

    /**
     * @since 1.0.0
     * @author Actually Portals
     */
    @Override public @NotNull ArrayList<Vec3> elaborate(int depth, int limit) {

        // Begin filling of vectors
        ArrayList<Vec3> ret = new ArrayList<>();
        int limited = limit;
        if (limited <= 0) { return ret; }

        // Calculate the last offset
        int S = getGridScale();
        int M = OotilityNumbers.floor(0.5 * S);

        // Funny layer fill randomized instead of sequential
        ArrayList<Integer> L = new ArrayList<>();
        ArrayList<Integer> d = new ArrayList<>();

        // Only for depth zero, top and bottom are pregenned
        int D = depth == 0 ? 1 : 0;
        if (depth == 0) { L.add(0); }
        if (depth == 0 && S > 1) { L.add(S - 1); }
        if (S > 2) { L.add(M); }
        for (int l = D; l < S-D; l++) {

            // Skip middle that got forcefully added before this
            if (l == M) { continue; }

            // Random chance of sequential, random chance of at the end
            if (OotilityNumbers.rollSuccess(0.5)) { L.add(l); } else { d.add(l); }
        }
        L.addAll(d);

        // Build this layer by layer
        for (int l = 0; l < S; l++) {

            // Calculate layer
            int ll = L.get(l);
            ASIGRectConstructor layer = genRect(ll);

            // Elaborate this layer
            ArrayList<Vec3> rec = layer.elaborate(0, limited);
            ret.addAll(rec);
            limited -= rec.size();
            if (limited <= 0) { return ret; }
        }

        // Done
        return ret;
    }

    /**
     * @param layer The layer of this cube that this rect will generate
     *
     * @return The rect to be used to generate that layer
     *
     * @since 1.0.0
     * @author Actually Portals
     */
     @NotNull public ASIGRectConstructor genRect(int layer) {

         // Generate a rect layer
         return ASIGRectConstructor.forSize(getGridScale(), true, false, 0, 0, layer, getOrigin());
     }
}
