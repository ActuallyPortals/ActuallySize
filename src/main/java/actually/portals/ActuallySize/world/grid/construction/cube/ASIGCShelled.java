package actually.portals.ActuallySize.world.grid.construction.cube;

import actually.portals.ActuallySize.world.grid.construction.ASIGConstructor;
import net.minecraft.world.phys.Vec3;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;

/**
 * Kind of like the layered constructor but first builds
 * the outer shell of the block in 3D then fills the
 * interior.
 *
 * @since 1.0.0
 * @author Actually Portals
 */
public class ASIGCShelled extends ASIGCubeConstructor {

    /**
     * @param s      The scale of the grid, presumably the ceil of the
     *               player's scale who is building this so that it
     *               is a non-zero natural number.
     *
     * @param origin A shift to the points generated by this rect
     *
     * @author Actually Portals
     * @since 1.0.0
     */
    public ASIGCShelled(int s, @NotNull Vec3 origin) { super(s, origin); }

    /**
     * @since 1.0.0
     * @author Actually Portals
     */
    @Override
    public @NotNull ArrayList<Vec3> elaborate(int depth, int limit) {

        // Begin filling of vectors
        ArrayList<Vec3> ret = new ArrayList<>();
        int limited = limit;
        if (limited <= 0) { return ret; }

        // Identify
        int S = getGridScale();

        // Begin with a shell
        boolean isEven = (S % 2 == 0);
        ASIGConstructor recurse = isEven ? new ASIGCEvenShell(S, getOrigin()) : new ASIGCOddShell(S, getOrigin());
        ArrayList<Vec3> rec = recurse.elaborate(depth, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        // End with a layered fill in the interior
        recurse = new ASIGCLayered(S - 2, getOrigin().add(1, 1, 1));
        rec = recurse.elaborate(depth + 1, limited);
        ret.addAll(rec);

        // Done
        return ret;
    }
}
