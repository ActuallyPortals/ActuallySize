package actually.portals.ActuallySize.world.grid.construction.rect;

import actually.portals.ActuallySize.world.grid.construction.ASIGConstructor;
import gunging.ootilities.GungingOotilitiesMod.ootilityception.OotilityNumbers;
import net.minecraft.world.phys.Vec2;
import net.minecraft.world.phys.Vec3;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;

/**
 * A grid constructor that fills an odd area
 *
 * @since 1.0.0
 * @author Actually Portals
 */
public class ASIGROdd extends ASIGRectConstructor {

    /**
     * @param s      The scale of the grid, presumably the ceil of the
     *               player's scale who is building this so that it
     *               is a non-zero natural number.
     * @param x      If this rect spans the x-direction
     * @param y      If this rect spans the y-direction
     *
     * @param normal The normal to the local origin grid plane
     * @param offset A shift to the points generated by this rect, in rect coordinates
     * @param origin A shift to the points generated by this rect, in world coordinates
     *
     * @author Actually Portals
     * @since 1.0.0
     */
    public ASIGROdd(int s, boolean x, boolean y, int normal, @NotNull Vec2 offset, @NotNull Vec3 origin) {
        super(s, x, y, normal, offset, origin);
    }

    /**
     * @since 1.0.0
     * @author Actually Portals
     */
    @Override
    public @NotNull ArrayList<Vec3> elaborate(int depth, int limit) {

        // Begin filling of vectors
        ArrayList<Vec3> ret = new ArrayList<>();
        int limited = limit;
        if (limited <= 0) { return ret; }

        // Identify indices
        int S = getGridScale();
        int k = 0;
        int K = S - 1 - k;
        int m = OotilityNumbers.floor(0.5 * S);
        int M = m + 1;

        // The corners are the first to be included, but only on depth 0
        if (depth == 0) {
            ret.add(cook(k,k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K,K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k,K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K,k)); limited--; if (limited <= 0) { return ret; }
        }

        // Add the midpoints
        ret.add(cook(k, m)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(K, m)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(m, k)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(m, K)); limited--; if (limited <= 0) { return ret; }

        // Add center
        ret.add(cook(m, m)); limited--; if (limited <= 0) { return ret; }

        // Done at size 3
        if (S == 3) { return ret; }

        // Recurse
        ASIGConstructor recurse = toSize(M, 0, 0);
        ArrayList<Vec3> rec = recurse.elaborate(depth + 1, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        recurse = toSize(M, m, m);
        rec = recurse.elaborate(depth + 1, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        // Minor fill corners
        int N = m - 1;
        ret.add(cook(N, M)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(M, N)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(k, M)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(K, N)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(M, k)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(N, K)); limited--; if (limited <= 0) { return ret; }

        // Minor fill edges
        recurse = toSize(m, 0, M);
        rec = recurse.elaborate(depth + 1, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        recurse = toSize(m, M, 0);
        ret.addAll(recurse.elaborate(depth + 1, limited));

        // Done
        return ret;
    }
}