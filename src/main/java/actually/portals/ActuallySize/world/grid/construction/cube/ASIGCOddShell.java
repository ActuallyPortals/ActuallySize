package actually.portals.ActuallySize.world.grid.construction.cube;

import actually.portals.ActuallySize.world.grid.construction.ASIGConstructor;
import actually.portals.ActuallySize.world.grid.construction.rect.ASIGRectConstructor;
import gunging.ootilities.GungingOotilitiesMod.ootilityception.OotilityNumbers;
import net.minecraft.world.phys.Vec3;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;

/**
 * Builds an odd shell and has no recursion
 *
 * @since 1.0.0
 * @author Actually Portals
 */
public class ASIGCOddShell extends ASIGCubeConstructor {

    /**
     * @param s      The scale of the grid, presumably the ceil of the
     *               player's scale who is building this so that it
     *               is a non-zero natural number.
     * @param origin A shift to the points generated by this rect
     *
     * @author Actually Portals
     * @since 1.0.0
     */
    public ASIGCOddShell(int s, @NotNull Vec3 origin) { super(s, origin); }

    /**
     * @since 1.0.0
     * @author Actually Portals
     */
    @Override public @NotNull ArrayList<Vec3> elaborate(int depth, int limit) {

        // Begin filling of vectors
        ArrayList<Vec3> ret = new ArrayList<>();
        int limited = limit;
        if (limited <= 0) { return ret; }

        // Identify indices
        int S = getGridScale();
        int k = 0;
        int K = S - 1 - k;
        int m = OotilityNumbers.floor(0.5 * S);

        // Just one block
        if (getGridScale() == 1) { if (depth == 0) { ret.add(cook(k,k,k)); } return ret; }

        // The corners are the first to be included, but only on depth 0
        if (depth == 0) {
            ret.add(cook(k,k,k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K,K,K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k,k,K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K,K,k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k,K,k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K,k,K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K,k,k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k,K,K)); limited--; if (limited <= 0) { return ret; }
        }

        // Add the edge midpoints
        ret.add(cook(m, k, k)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(k, K, m)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(k, m, K)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(m, K, k)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(k, k, m)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(k, m, k)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(m, K, K)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(K, k, m)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(K, m, k)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(m, k, K)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(K, K, m)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(K, m, K)); limited--; if (limited <= 0) { return ret; }

        // Fill edges
        for (int i = k + 1; i < m; i++) {
            ret.add(cook(i, k, k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k, K, i)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k, i, K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(i, K, k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k, k, i)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k, i, k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(i, K, K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K, k, i)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K, i, k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(i, k, K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K, K, i)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K, i, K)); limited--; if (limited <= 0) { return ret; }
        }

        for (int j = m + 1; j < K; j++) {
            ret.add(cook(j, K, K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K, k, j)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K, j, k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(j, k, K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K, K, j)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K, j, K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(j, k, k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k, K, j)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k, j, K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(j, K, k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k, k, j)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k, j, k)); limited--; if (limited <= 0) { return ret; }
        }

        // Fill sides
        ASIGConstructor recurse = genRect(true, false, k);
        ArrayList<Vec3> rec = recurse.elaborate(depth, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        recurse = genRect(true, false, K);
        rec = recurse.elaborate(depth, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        // X then Z
        if (OotilityNumbers.rollSuccess(0.5)) {
            recurse = genRect(true, true, k);
            rec = recurse.elaborate(depth, limited);
            ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

            recurse = genRect(true, true, K);
            rec = recurse.elaborate(depth, limited);
            ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

            recurse = genRect(false, true, k);
            rec = recurse.elaborate(depth, limited);
            ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

            recurse = genRect(false, true, K);
            rec = recurse.elaborate(depth, limited);
            ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        // Z then X
        } else {
            recurse = genRect(false, true, k);
            rec = recurse.elaborate(depth, limited);
            ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

            recurse = genRect(false, true, K);
            rec = recurse.elaborate(depth, limited);
            ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

            recurse = genRect(true, true, k);
            rec = recurse.elaborate(depth, limited);
            ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

            recurse = genRect(true, true, K);
            rec = recurse.elaborate(depth, limited);
            ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }
        }

        // Done
        return ret;
    }

    /**
     * @param x If this rect spans the x-direction
     * @param y If this rect spans the y-direction
     * @param offset The offset for this rect, presumably k or K
     *
     * @return The rect to be used to generate that face
     *
     * @since 1.0.0
     * @author Actually Portals
     */
    @NotNull public ASIGRectConstructor genRect(boolean x, boolean y, int offset) {

        // Generate a rect face
        return ASIGRectConstructor.forSize(getGridScale() - 2, x, y, 1, 1, offset, getOrigin());
    }
}