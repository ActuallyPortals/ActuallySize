package actually.portals.ActuallySize.world.grid.construction.rect;

import actually.portals.ActuallySize.world.grid.construction.ASIGConstructor;
import gunging.ootilities.GungingOotilitiesMod.ootilityception.OotilityNumbers;
import net.minecraft.world.phys.Vec2;
import net.minecraft.world.phys.Vec3;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;

/**
 * A grid constructor that fills an even-sized rect
 *
 * @since 1.0.0
 * @author Actually Portals
 */
public class ASIGREven extends ASIGRectConstructor {

    /**
     * If both x and y params are set to false, x is forced to true
     * so that the plane of choosing is the X-Z plane
     *
     * @param s      The scale of the grid
     * @param x      If this rect spans the x-direction
     * @param y      If this rect spans the y-direction
     *
     * @param normal The normal to the local origin grid plane
     * @param offset A shift to the points generated by this rect, in rect coordinates
     * @param origin A shift to the points generated by this rect, in world coordinates
     *
     * @author Actually Portals
     * @since 1.0.0
     */
    public ASIGREven(int s, boolean x, boolean y, int normal, @NotNull Vec2 offset, @NotNull Vec3 origin) {
        super(s, x, y, normal, offset, origin);
    }

    /**
     * @since 1.0.0
     * @author Actually Portals
     */
    @Override
    public @NotNull ArrayList<Vec3> elaborate(int depth, int limit) {

        // Begin filling of vectors
        ArrayList<Vec3> ret = new ArrayList<>();
        int limited = limit;
        if (limited <= 0) { return ret; }

        // Identify indices
        int S = getGridScale();
        int k = 0;
        int K = S - 1 - k;
        int m = OotilityNumbers.floor(0.5 * S) - 1;
        int M = OotilityNumbers.ceil(0.5 * S);

        // The corners are the first to be included, but only on depth 0
        if (depth == 0) {
            ret.add(cook(k,k)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K,K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(k,K)); limited--; if (limited <= 0) { return ret; }
            ret.add(cook(K,k)); limited--; if (limited <= 0) { return ret; }
        }

        // Add the midpoints
        ret.add(cook(k, m)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(K, M)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(M, k)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(m, K)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(k, M)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(K, m)); limited--; if (limited <= 0) { return ret; }

        ret.add(cook(m, k)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(M, K)); limited--; if (limited <= 0) { return ret; }

        // Add centers
        ret.add(cook(m, m)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(M, M)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(m, M)); limited--; if (limited <= 0) { return ret; }
        ret.add(cook(M, m)); limited--; if (limited <= 0) { return ret; }

        // Done at size 4
        if (S == 4) { return ret; }

        // Recurse
        ASIGConstructor recurse = toSize(M, 0, 0);
        ArrayList<Vec3> rec = recurse.elaborate(depth + 1, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        recurse = toSize(M, M, M);
        rec = recurse.elaborate(depth + 1, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        recurse = toSize(M, 0, M);
        rec = recurse.elaborate(depth + 1, limited);
        ret.addAll(rec); limited -= rec.size(); if (limited <= 0) { return ret; }

        recurse = toSize(M, M, 0);
        ret.addAll(recurse.elaborate(depth + 1, limited));

        // Done
        return ret;
    }
}
